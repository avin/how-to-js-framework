# Урок 1: Введение

## Что такое фреймворк?

Фреймворк — это набор инструментов и соглашений, которые упрощают создание веб-приложений. Вместо того, чтобы каждый раз писать код для работы с DOM, обновления интерфейса и управления состоянием с нуля, фреймворк предоставляет готовые решения этих задач.

## Зачем нужны фреймворки?

Представьте, что вы создаете интерактивное приложение на чистом JavaScript:

```javascript
// Без фреймворка - императивный подход
const button = document.createElement('button');
button.textContent = 'Счётчик: 0';
let count = 0;

button.addEventListener('click', () => {
  count++;
  button.textContent = `Счётчик: ${count}`;
});

document.body.appendChild(button);
```

Что здесь происходит?
1. Мы создаём элемент
2. Устанавливаем начальный текст
3. Добавляем обработчик события
4. При клике обновляем состояние И вручную обновляем DOM

**Проблема**: По мере роста приложения вы должны вручную:
- Создавать и удалять элементы
- Синхронизировать состояние с интерфейсом
- Помнить, какие части UI нужно обновить при изменении данных
- Управлять памятью и подписками

## Как фреймворк решает эти проблемы?

Современные фреймворки используют **декларативный подход**:

```javascript
// С фреймворком - декларативный подход
function Counter() {
  const [count, setCount] = useState(0);

  return (
    <button onClick={() => setCount(count + 1)}>
      Счётчик: {count}
    </button>
  );
}
```

Теперь вы **описываете**, как должен выглядеть интерфейс, а фреймворк **сам** решает:
- Как создать элементы
- Когда и что обновить
- Как оптимизировать изменения

## Ключевые концепции фреймворков

### 1. Декларативность

Вместо шагов "как сделать" вы описываете "что должно быть":

```javascript
// Императивно (как сделать)
if (isLoggedIn) {
  const welcome = document.createElement('h1');
  welcome.textContent = 'Добро пожаловать!';
  container.appendChild(welcome);
} else {
  const login = document.createElement('button');
  login.textContent = 'Войти';
  container.appendChild(login);
}

// Декларативно (что должно быть)
return isLoggedIn
  ? <h1>Добро пожаловать!</h1>
  : <button>Войти</button>;
```

### 2. Реактивность

Когда данные меняются, интерфейс автоматически обновляется:

```javascript
const [name, setName] = useState('Иван');

// При вызове setName('Петр'), фреймворк автоматически
// обновит все части UI, которые используют name
```

### 3. Компонентная архитектура

Разбиение интерфейса на независимые, переиспользуемые части:

```javascript
function App() {
  return (
    <div>
      <Header />
      <MainContent />
      <Footer />
    </div>
  );
}
```

### 4. Virtual DOM

Вместо прямой работы с DOM, фреймворк:
1. Создаёт виртуальное представление интерфейса (JavaScript объект)
2. При изменениях сравнивает старое и новое виртуальное дерево
3. Применяет только необходимые изменения к реальному DOM

**Зачем?** Работа с реальным DOM медленная. Virtual DOM позволяет:
- Батчить (группировать) изменения
- Вычислять минимальный набор операций
- Делать обновления более предсказуемыми

## Какие проблемы мы будем решать?

При создании нашего фреймворка мы разберём и решим следующие задачи:

1. **Представление UI в виде данных** - как описать дерево элементов
2. **Рендеринг** - превращение описания в реальный DOM
3. **Эффективное обновление** - как обновлять только изменённые части
4. **Управление состоянием** - где хранить данные и как реагировать на изменения
5. **Переиспользование** - создание компонентов
6. **Побочные эффекты** - работа с API, таймерами и т.д.

## Что мы построим?

Наш фреймворк будет называться **NanoFramework** и будет включать:

```javascript
// API нашего фреймворка
import { h, render, useState, useEffect } from './nano-framework';

function TodoApp() {
  const [todos, setTodos] = useState([]);
  const [input, setInput] = useState('');

  const addTodo = () => {
    setTodos([...todos, { id: Date.now(), text: input }]);
    setInput('');
  };

  return h('div', { class: 'app' }, [
    h('input', {
      value: input,
      onInput: (e) => setInput(e.target.value)
    }),
    h('button', { onClick: addTodo }, 'Добавить'),
    h('ul', null,
      todos.map(todo =>
        h('li', { key: todo.id }, todo.text)
      )
    )
  ]);
}

render(TodoApp, document.getElementById('app'));
```

## Чего НЕ будет в нашем фреймворке?

Для простоты обучения мы не будем реализовывать:
- JSX (будем использовать функцию `h()`)
- TypeScript (используем чистый JS)
- Серверный рендеринг
- Продвинутую оптимизацию (мемоизация, ленивая загрузка и т.д.)
- Роутинг
- Глобальное управление состоянием (Redux-подобное)

Фокус курса — понять **ключевые концепции**, а не создать production-ready решение.

## Инструменты

Для прохождения курса вам понадобится:
- Текстовый редактор (VS Code, WebStorm и т.д.)
- Браузер с DevTools
- Node.js (для запуска примеров, опционально)

Мы будем писать на чистом JavaScript (ES6+), без сборщиков. Для тестирования просто откройте HTML файл в браузере.

## План следующих уроков

В следующем уроке мы погрузимся в концепцию **Virtual DOM**:
- Что это такое
- Почему это быстрее прямой работы с DOM
- Как представить дерево элементов в виде объектов

## Задание

Подумайте над вопросами:
1. Какие фреймворки вы использовали? Что вам в них нравится/не нравится?
2. Напишите простой счётчик на чистом JavaScript без фреймворков
3. Попробуйте добавить к счётчику историю изменений - станет понятно, почему ручное управление состоянием сложное

## Дополнительные материалы

- [The Virtual DOM](https://github.com/Matt-Esch/virtual-dom) - одна из первых реализаций
- [React Docs: Reconciliation](https://react.dev/learn/preserving-and-resetting-state) - как React обновляет DOM
- [You Don't Need a Framework](https://www.youtube.com/watch?v=VvOguri6PV) - почему иногда фреймворк не нужен

---

[Следующий урок: Virtual DOM - концепция →](./02-virtual-dom-concept.md)
